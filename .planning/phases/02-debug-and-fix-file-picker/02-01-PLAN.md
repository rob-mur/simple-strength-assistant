---
phase: 02-debug-and-fix-file-picker
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/state/workout_state.rs
  - src/app.rs
autonomous: true
requirements: [DB-01, ERR-01, ERR-04]

must_haves:
  truths:
    - "File picker dialog appears when user clicks 'Select Database Location' button"
    - "Browser console shows detailed error messages for file picker failures"
    - "User gesture requirement is satisfied before calling showSaveFilePicker()"
  artifacts:
    - path: "src/state/workout_state.rs"
      provides: "Modified setup_database to not auto-prompt, only check cache"
      contains: "setup_database no longer calls prompt_for_file when !has_cached"
    - path: "src/app.rs"
      provides: "SelectingFile UI with button that provides user gesture"
      contains: "button onclick handler that calls prompt_for_file"
  key_links:
    - from: "src/app.rs"
      to: "FileSystemManager::prompt_for_file()"
      via: "button onclick → spawn → prompt_for_file"
      pattern: "onclick.*spawn.*prompt_for_file"
    - from: "src/state/file_system.rs"
      to: "window.showSaveFilePicker"
      via: "js_sys::Reflect call within user gesture context"
      pattern: "showSaveFilePicker.*call1"
---

<objective>
Fix file picker not appearing by ensuring showSaveFilePicker() is called from a user gesture (button click) instead of automatically during initialization.

Purpose: The File System Access API requires "transient user activation" (must be called within ~5 seconds of user interaction). Current code calls prompt_for_file() from use_effect without user gesture, causing SecurityError.

Output: File picker dialog appears when user clicks button in SelectingFile state, console shows clear error messages for debugging.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-debug-and-fix-file-picker/02-RESEARCH.md

<interfaces>
<!-- Key interfaces from codebase -->

From src/state/file_system.rs:
```rust
pub struct FileSystemManager {
    handle: Option<JsValue>,
    use_fallback: bool,
}

impl FileSystemManager {
    pub fn new() -> Self;
    pub async fn check_cached_handle(&mut self) -> Result<bool, FileSystemError>;
    pub async fn prompt_for_file(&mut self) -> Result<FileHandle, FileSystemError>;
    pub fn has_handle(&self) -> bool;
}

#[derive(Error, Debug, Clone)]
pub enum FileSystemError {
    #[error("File System Access API not supported")]
    NotSupported,
    #[error("User cancelled file selection")]
    UserCancelled,
    #[error("Permission denied. Please grant file access to continue.")]
    PermissionDenied,
    // ... other variants
}
```

From src/state/workout_state.rs:
```rust
#[derive(Clone, Copy, PartialEq, Debug)]
pub enum InitializationState {
    NotInitialized,
    Initializing,
    SelectingFile,  // <-- UI should show button in this state
    Ready,
    Error,
}

pub struct WorkoutState {
    inner: Rc<RefCell<WorkoutStateInner>>,
}

impl WorkoutState {
    pub fn set_initialization_state(&self, state: InitializationState);
}

impl WorkoutStateManager {
    pub async fn setup_database(state: &WorkoutState) -> Result<(), String>;
}
```
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: Fix setup_database to stop auto-prompting for file</name>
  <files>src/state/workout_state.rs</files>
  <action>
Modify WorkoutStateManager::setup_database() to NOT call prompt_for_file() when there's no cached handle. Instead, set state to SelectingFile and return early, letting the UI handle the user gesture.

Current problematic code (lines 157-167):
```rust
if !has_cached {
    web_sys::console::log_1(&"[DB Init] No cached handle, prompting for file...".into());
    state.set_initialization_state(InitializationState::SelectingFile);

    file_manager.prompt_for_file().await.map_err(|e| {
        let msg = format!("Failed to prompt for file: {}", e);
        web_sys::console::error_1(&msg.clone().into());
        msg
    })?;
    web_sys::console::log_1(&"[DB Init] File selected successfully".into());
}
```

Replace with:
```rust
if !has_cached {
    web_sys::console::log_1(&"[DB Init] No cached handle, transitioning to SelectingFile state".into());
    web_sys::console::log_1(&"[DB Init] File picker requires user gesture - waiting for button click".into());
    state.set_initialization_state(InitializationState::SelectingFile);

    // Return early - UI will call prompt_for_file from button onclick
    // which provides the required user gesture (transient activation)
    return Err("Waiting for user to select file - not an error, normal flow".to_string());
}
```

This ensures showSaveFilePicker() will only be called when the user clicks the button in SelectingFile UI, providing the required transient user activation.
  </action>
  <verify>
    <automated>cargo check --target wasm32-unknown-unknown 2>&1 | grep -E "(error|warning.*setup_database)" || echo "Build successful"</automated>
  </verify>
  <done>setup_database no longer auto-calls prompt_for_file, instead sets SelectingFile state and returns early, console logs explain user gesture requirement</done>
</task>

<task type="auto">
  <name>Task 2: Add file selection button to SelectingFile UI with inline initialization</name>
  <files>src/app.rs</files>
  <action>
Modify the InitializationState::SelectingFile match arm (lines 53-76) to include a button that calls prompt_for_file() from its onclick handler and continues initialization inline without calling setup_database again. This avoids fragile error message string matching.

Current UI just shows informational text with no button. Replace the card-body content with:

```rust
div {
    class: "card-body",
    h2 {
        class: "card-title",
        "Select Database File"
    }
    p {
        "Please select or create a database file to store your workout data."
    }
    p {
        class: "text-sm text-gray-600 mt-2",
        "Your data will be stored locally on your device and remain completely private."
    }
    div {
        class: "card-actions justify-end mt-4",
        button {
            class: "btn btn-primary",
            onclick: move |_| {
                let state_for_select = workout_state.clone();
                spawn(async move {
                    web_sys::console::log_1(&"[UI] User clicked file selection button - has user gesture".into());
                    let mut file_manager = crate::state::FileSystemManager::new();

                    match file_manager.prompt_for_file().await {
                        Ok(_) => {
                            web_sys::console::log_1(&"[UI] File selected successfully".into());

                            // Continue initialization inline - file_manager already has handle from prompt_for_file
                            state_for_select.set_initialization_state(InitializationState::Initializing);

                            // Initialize database with the selected handle
                            match crate::state::DatabaseManager::initialize(&file_manager).await {
                                Ok(db) => {
                                    web_sys::console::log_1(&"[UI] Database initialized successfully".into());
                                    state_for_select.set_database(db);
                                    state_for_select.set_initialization_state(InitializationState::Ready);
                                }
                                Err(e) => {
                                    let error_msg = format!("Database initialization failed: {}", e);
                                    web_sys::console::error_1(&error_msg.clone().into());
                                    crate::state::WorkoutStateManager::handle_error(&state_for_select, error_msg);
                                }
                            }
                        }
                        Err(e) => {
                            let error_msg = format!("File selection failed: {}", e);
                            web_sys::console::error_1(&error_msg.clone().into());
                            crate::state::WorkoutStateManager::handle_error(&state_for_select, error_msg);
                        }
                    }
                });
            },
            "Select Database Location"
        }
    }
}
```

CRITICAL: This approach continues initialization inline after successful file selection instead of calling setup_database again. This eliminates the fragile error message string matching pattern (`if !e.contains("Waiting for user")`) and provides a clear linear control flow: button click → prompt_for_file → initialize database → set Ready state.

The file_manager already has the handle after prompt_for_file() succeeds, so we proceed directly to DatabaseManager::initialize() without re-checking the cache. This is the clean control flow solution recommended in the checker issue.
  </action>
  <verify>
    <automated>cargo check --target wasm32-unknown-unknown 2>&1 | grep -E "(error|warning.*SelectingFile)" || echo "Build successful"</automated>
  </verify>
  <done>SelectingFile UI includes button, onclick handler calls prompt_for_file with user gesture context and continues initialization inline without calling setup_database again, eliminating fragile error message string matching</done>
</task>

<task type="auto">
  <name>Task 3: Add SecurityError variant and improve error logging with stack traces in file_system.rs</name>
  <files>src/state/file_system.rs</files>
  <action>
Add SecurityError enum variant to FileSystemError and enhance error detection in prompt_for_file() to distinguish SecurityError (no user gesture) from other errors. Include stack trace capture for WASM-JS boundary errors (ERR-04).

1. Add SecurityError variant to FileSystemError enum (after line 32):
```rust
#[error("Security error: File picker requires user gesture (button click)")]
SecurityError,
```

2. In prompt_for_file(), enhance the error handling at line 160-173 to detect SecurityError and capture stack traces:
```rust
let promise = picker_fn.call1(&window, &options).map_err(|e| {
    let error_string = format!("{:?}", e);
    web_sys::console::error_1(&"[FileSystem] showSaveFilePicker call failed".into());
    web_sys::console::error_1(&format!("[FileSystem] Error details: {}", error_string).into());

    // Capture stack trace for WASM-JS boundary errors (ERR-04)
    if let Ok(stack) = js_sys::Reflect::get(&e, &"stack".into()) {
        if !stack.is_undefined() {
            web_sys::console::error_1(&format!("[FileSystem] Stack trace: {:?}", stack).into());
        }
    }

    let error_lower = error_string.to_lowercase();

    if error_lower.contains("securityerror") || error_lower.contains("user gesture") {
        web_sys::console::error_1(&"[FileSystem] CAUSE: File picker requires user gesture (must be called from button click)".into());
        FileSystemError::SecurityError
    } else if error_lower.contains("notallowederror") || error_lower.contains("permission") {
        web_sys::console::error_1(&"[FileSystem] CAUSE: User denied permission".into());
        FileSystemError::PermissionDenied
    } else if error_lower.contains("abort") {
        web_sys::console::log_1(&"[FileSystem] User cancelled file picker dialog".into());
        FileSystemError::UserCancelled
    } else {
        FileSystemError::JsError(error_string)
    }
})?;
```

3. Apply same enhanced error detection with stack trace capture to the JsFuture::await error handler (lines 175-192):
```rust
.map_err(|e| {
    let error_string = format!("{:?}", e);
    web_sys::console::error_1(&"[FileSystem] File picker promise failed".into());
    web_sys::console::error_1(&format!("[FileSystem] Error details: {}", error_string).into());

    // Capture stack trace for WASM-JS boundary errors (ERR-04)
    if let Ok(stack) = js_sys::Reflect::get(&e, &"stack".into()) {
        if !stack.is_undefined() {
            web_sys::console::error_1(&format!("[FileSystem] Stack trace: {:?}", stack).into());
        }
    }

    // ... same error type detection as above
})?;
```

This provides clear console diagnostics showing exactly WHY the file picker failed with full stack traces for debugging WASM-JS boundary issues, making it easy to debug user gesture issues vs permission issues vs cancellation.
  </action>
  <verify>
    <automated>cargo check --target wasm32-unknown-unknown 2>&1 | grep -E "(error|warning.*SecurityError|warning.*FileSystemError)" || echo "Build successful"</automated>
  </verify>
  <done>FileSystemError has SecurityError variant, prompt_for_file logs distinguish SecurityError/PermissionDenied/UserCancelled with detailed console messages explaining cause, stack traces captured and logged for all WASM-JS boundary errors</done>
</task>

</tasks>

<verification>
1. Run `dx serve --port 8080 --open false` to start development server
2. Open browser to http://localhost:8080
3. Open DevTools console (F12)
4. Observe initialization flow in console logs:
   - Should see "[DB Init] No cached handle, transitioning to SelectingFile state"
   - Should see "[DB Init] File picker requires user gesture - waiting for button click"
   - UI should show "Select Database Location" button (not just loading spinner)
5. Click "Select Database Location" button
6. File picker dialog should appear (native browser dialog)
7. Console should show "[UI] User clicked file selection button - has user gesture"
8. If file picker fails, console should show specific error type (SecurityError/PermissionDenied/UserCancelled) with explanation

Expected outcome: File picker appears after button click, no SecurityError because button provides user gesture.
</verification>

<success_criteria>
- [ ] File picker dialog appears when user clicks "Select Database Location" button
- [ ] No SecurityError in console (user gesture is provided by button click)
- [ ] Console logs clearly distinguish error types: SecurityError vs PermissionDenied vs UserCancelled
- [ ] setup_database no longer auto-calls prompt_for_file when no cached handle exists
- [ ] SelectingFile UI shows actionable button instead of just informational text
</success_criteria>

<output>
After completion, create `.planning/phases/02-debug-and-fix-file-picker/02-01-SUMMARY.md`
</output>

---
phase: 03-verify-and-polish
plan: 01
type: execute
wave: 1
depends_on: []
files_modified: [src/app.rs, src/state/file_system.rs]
autonomous: false
requirements: [DB-03, DB-05, DB-06, ERR-03]

must_haves:
  truths:
    - "User can select database file and it persists across browser refresh"
    - "Database initialization completes successfully after file selection"
    - "LocalStorage fallback works in Firefox/Safari when API unavailable"
    - "Invalid file formats show user-friendly error messages with recovery guidance"
  artifacts:
    - path: "src/app.rs"
      provides: "Enhanced error UI with user-friendly messages and recovery instructions"
      min_lines: 200
      contains: "parse_error_for_ui"
    - path: "src/state/file_system.rs"
      provides: "Storage mode detection method"
      exports: ["is_using_fallback"]
  key_links:
    - from: "src/app.rs"
      to: "FileSystemError variants"
      via: "Error message parsing in parse_error_for_ui"
      pattern: "error_lower\\.contains\\("
    - from: "src/app.rs"
      to: "FileSystemManager"
      via: "Storage mode indicator check"
      pattern: "is_using_fallback\\(\\)"
---

<objective>
Verify complete database initialization flow works end-to-end with proper error handling and polish user experience for common failure modes.

Purpose: Ensure users can reliably initialize database in all browsers, understand error conditions when they occur, and know their data storage mode (file vs browser storage).

Output: Production-ready database initialization with comprehensive error UX, fallback mode indicators, and verified cross-session persistence.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-verify-and-polish/03-RESEARCH.md

# Prior phase implementation
@.planning/phases/02-debug-and-fix-file-picker/02-01-SUMMARY.md
@.planning/phases/02-debug-and-fix-file-picker/02-02-SUMMARY.md
@.planning/phases/02-debug-and-fix-file-picker/02-03-SUMMARY.md

<interfaces>
<!-- Key types and contracts from Phase 2 implementation -->

From src/state/workout_state.rs:
```rust
pub enum InitializationState {
    NotInitialized,
    Initializing,
    SelectingFile,
    Ready,
    Error,
}

pub struct WorkoutState {
    initialization_state: Signal<InitializationState>,
    error_message: Signal<Option<String>>,
    database: Signal<Option<Database>>,
    file_manager: Signal<Option<FileSystemManager>>,
    current_session: Signal<Option<WorkoutSession>>,
}

impl WorkoutState {
    pub fn error_message(&self) -> Option<String>;
    pub fn set_error_message(&self, message: Option<String>);
    pub fn set_initialization_state(&self, state: InitializationState);
    pub fn file_manager(&self) -> Option<FileSystemManager>;
}

pub struct WorkoutStateManager;
impl WorkoutStateManager {
    pub fn handle_error(state: &WorkoutState, error: String);
}
```

From src/state/file_system.rs:
```rust
#[derive(Error, Debug, Clone)]
pub enum FileSystemError {
    NotSupported,
    UserCancelled,
    PermissionDenied,
    SecurityError,
    ReadError(String),
    WriteError(String),
    JsError(String),
    NoHandle,
    FileTooLarge,      // Max 100 MB
    InvalidFormat,     // Not a valid SQLite database (magic number check)
}

pub struct FileSystemManager {
    handle: Option<JsValue>,
    use_fallback: bool,
}

impl FileSystemManager {
    pub fn new() -> Self;
    pub fn has_handle(&self) -> bool;
    pub async fn check_cached_handle(&mut self) -> Result<bool, FileSystemError>;
    pub async fn prompt_for_file(&mut self) -> Result<FileHandle, FileSystemError>;
    pub async fn read_file(&mut self) -> Result<Vec<u8>, FileSystemError>;
    // Need to add: pub fn is_using_fallback(&self) -> bool;
}

const SQLITE_MAGIC_NUMBER: &[u8] = b"SQLite format 3\0";
// Validation in read_file(): buffer.starts_with(SQLITE_MAGIC_NUMBER)
```

From public/file-handle-storage.js:
```javascript
export async function storeFileHandle(handle);      // Store in IndexedDB
export async function retrieveFileHandle();          // Get from IndexedDB with permission check
export async function clearFileHandle();             // Remove stale handle
// Permission states: 'granted', 'prompt', 'denied'
// queryPermission() -> requestPermission() flow implemented
```
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add user-friendly error message handling</name>
  <files>src/app.rs</files>
  <action>
Enhance the InitializationState::Error UI to display user-friendly error messages with recovery instructions instead of raw technical errors.

Add helper function `parse_error_for_ui(error_msg: &str) -> ErrorInfo` that returns:
```rust
struct ErrorInfo {
    title: String,        // Bold, scannable headline
    message: String,      // Plain language explanation
    recovery_tip: Option<String>,  // Actionable next step
    retry_label: String,  // Button text
}
```

Map FileSystemError variants to user-friendly messages:
1. "not a valid SQLite database" / "invalid format" →
   - Title: "Invalid File Format"
   - Message: "The selected file is not a valid SQLite database."
   - Tip: "Please select a .sqlite or .db file, or create a new database file."
   - Button: "Select Different File"

2. "permission denied" / "notallowederror" →
   - Title: "Permission Denied"
   - Message: "File access permission was not granted."
   - Tip: "Grant permission to access the file, or use browser storage instead."
   - Button: "Grant Permission"

3. "user cancelled" →
   - Title: "File Selection Cancelled"
   - Message: "No database file was selected."
   - Tip: "Click below to select where to store your workout data."
   - Button: "Select File"

4. "file is too large" / "filetoolarge" →
   - Title: "File Too Large"
   - Message: "The selected database file exceeds the 100 MB limit."
   - Tip: "Try selecting a smaller file or export your data to start fresh."
   - Button: "Select Different File"

5. "failed to initialize database" →
   - Title: "Database Initialization Failed"
   - Message: "Could not set up the database. The file may be corrupted."
   - Tip: "Try selecting a different file or creating a new database."
   - Button: "Try Again"

6. Default case →
   - Title: "Initialization Error"
   - Message: {raw error message}
   - Tip: "Check your browser console for details and try again."
   - Button: "Retry"

Update the InitializationState::Error rsx! block to use parse_error_for_ui and display:
- Alert card with error styling
- Bold title + plain language message
- Recovery tip (if present) with emoji icon
- Retry button with appropriate label that calls setup_database again

Preserve existing error flow: errors still set via WorkoutStateManager::handle_error, only the display changes.
  </action>
  <verify>
Compile check: cargo build --target wasm32-unknown-unknown

Manual verification:
1. Trigger InvalidFormat error: Select .txt file → UI shows "Invalid File Format" with recovery tip
2. Trigger UserCancelled: Click button then cancel picker → UI shows "File Selection Cancelled"
3. Check error_info mapping: All 6 error types have appropriate titles and recovery instructions
4. Verify retry button: Click retry → calls setup_database, clears error state
  </verify>
  <done>
Error state UI displays user-friendly messages with recovery instructions for all FileSystemError variants. Users understand what went wrong and what action to take next.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add storage mode indicator for fallback users</name>
  <files>src/state/file_system.rs, src/app.rs</files>
  <action>
Add storage mode detection and user notification for when fallback storage is active.

**Part 1: Add is_using_fallback method to FileSystemManager (file_system.rs)**

Add public getter method:
```rust
impl FileSystemManager {
    pub fn is_using_fallback(&self) -> bool {
        self.use_fallback
    }
}
```

This exposes the existing `use_fallback` field which is set during new() based on is_file_system_api_supported() check.

**Part 2: Add storage mode banner to Ready state (app.rs)**

In the InitializationState::Ready rsx! block (currently not shown in app.rs slice), add conditional info banner BEFORE the workout interface:

```rust
InitializationState::Ready => {
    let storage_mode_info = if let Some(fm) = workout_state.file_manager() {
        if fm.is_using_fallback() {
            Some(rsx! {
                div {
                    class: "alert alert-info mb-4",
                    svg { /* info icon - use heroicons or DaisyUI default */ }
                    div {
                        h4 { class: "font-bold", "Browser Storage Mode" }
                        p { class: "text-sm",
                            "Your data is stored in browser LocalStorage. ",
                            "This works offline but won't sync across devices or browsers."
                        }
                    }
                }
            })
        } else {
            None
        }
    } else {
        None
    };

    rsx! {
        div {
            {storage_mode_info}
            // Existing workout interface components here
        }
    }
}
```

Use DaisyUI alert-info styling (already available in project - Phase 1 uses DaisyUI). Place banner at top of content area, above workout session UI.

**Why:** Users in Firefox or Safari private mode need to understand their data won't be portable. This prevents confusion when switching browsers or clearing data.
  </action>
  <verify>
Compile check: cargo build --target wasm32-unknown-unknown

Manual testing:
1. Chrome with File System API: Verify NO info banner appears (file mode)
2. Firefox (no File System API): Verify blue info banner appears at top of Ready state
3. Console check: Firefox logs "[FileSystem] Using fallback storage"
4. Visual check: Banner styling matches DaisyUI alert-info (blue background, info icon)
  </verify>
  <done>
FileSystemManager exposes is_using_fallback() method. Ready state shows informational banner when fallback storage is active. Users understand data portability limitations.
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <name>Task 3: Verify end-to-end database initialization flow</name>
  <what-built>
Enhanced error UX with user-friendly messages and fallback storage indicators. This completes the database initialization flow with proper error handling for all FileSystemError variants and clear communication about storage mode.

**Implementation details:**
- Error messages map FileSystemError variants to plain language with recovery actions
- Storage mode banner informs fallback users about LocalStorage limitations
- All error paths tested and verified during development

**Testing completed during implementation:**
- Compile verification passed (WASM target)
- Error message parsing tested for all 6 error types
- Storage mode indicator tested in Chrome (no banner) and fallback mode
  </what-built>

  <how-to-verify>
Run comprehensive end-to-end test protocol to verify all Phase 3 requirements (DB-03, DB-05, DB-06, ERR-03).

**Test Environment Setup:**
1. Start dev server: `dx serve --port 8080 --open false`
2. Have 3 test files ready:
   - `test-valid.sqlite` (empty or valid SQLite file)
   - `test-invalid.txt` (not a SQLite file)
   - `test-empty.sqlite` (0 bytes)

**Test Protocol:**

### Test 1: DB-03 - File Handle Persistence (Chrome/Edge)
1. Open http://localhost:8080 in Chrome (fresh profile or incognito)
2. Click "Select Database Location" button
3. Select/create "test-valid.sqlite", grant permission
4. Wait for Ready state (shows "Start New Workout Session")
5. **Press F5 to refresh browser**
6. Expected: App auto-initializes to Ready state WITHOUT showing file picker button
7. Console should show: "[FileHandleStorage] Permission state: granted"
8. Verify: Can use app immediately after refresh (handle persisted)

**Result:** [ ] Pass [ ] Fail

---

### Test 2: DB-05 - Database Initialization Success (New File)
1. Fresh browser session
2. Click "Select Database Location"
3. Create NEW file "workout-new.sqlite"
4. Grant permission
5. Expected console logs in order:
   - "[UI] File is empty, creating new database"
   - "[DB] initDatabase succeeded, creating tables..."
   - "[DB] Tables created successfully"
   - "[UI] Database initialized successfully"
   - "[UI] Setup complete! State is now Ready"
6. Expected UI: Shows workout session form (not error)

**Result:** [ ] Pass [ ] Fail

---

### Test 3: DB-05 - Database Initialization Success (Existing File)
1. Use existing valid SQLite file (if available, otherwise skip)
2. Click "Select Database Location"
3. Select file with existing data
4. Expected console logs:
   - "[UI] Read X bytes from file"
   - "[DB] Database loaded from file data"
   - "[DB] Tables created successfully"
5. Expected: Ready state, can query existing data

**Result:** [ ] Pass [ ] Fail [ ] Skipped (no existing file)

---

### Test 4: DB-06 - LocalStorage Fallback (Firefox)
1. Open http://localhost:8080 in **Firefox** (latest version)
2. Expected behavior:
   - NO file picker button shown
   - Console logs: "[FileSystem] Using fallback storage"
   - Blue info banner: "Browser Storage Mode"
   - Message mentions: "stored in browser LocalStorage"
3. Auto-initializes to Ready state immediately
4. Start workout, log 2-3 sets, complete session
5. **Press F5 to refresh**
6. Expected: Data persists (previous session visible)
7. Open DevTools → Storage → Local Storage → localhost:8080
8. Verify key "workout_db_data" exists with data

**Result:** [ ] Pass [ ] Fail

---

### Test 5: ERR-03 - Invalid File Format (.txt)
1. Chrome browser, fresh session
2. Click "Select Database Location"
3. Select "test-invalid.txt" (not a SQLite file)
4. Expected error UI:
   - Title: "Invalid File Format"
   - Message: "The selected file is not a valid SQLite database."
   - Tip: "Please select a .sqlite or .db file..."
   - Button: "Select Different File"
5. Click retry button
6. Expected: Returns to SelectingFile state, can try again

**Result:** [ ] Pass [ ] Fail

---

### Test 6: ERR-03 - Empty File Handling
1. Click "Select Database Location"
2. Select "test-empty.sqlite" (0 bytes)
3. Expected: Treated as NEW database (not error)
4. Console: "[UI] File is empty, creating new database"
5. Initializes successfully to Ready state

**Result:** [ ] Pass [ ] Fail

---

### Test 7: Permission Denied Error (if possible)
1. If browser allows blocking permission: Click button, select file, DENY permission
2. Expected error UI:
   - Title: "Permission Denied"
   - Message: "File access permission was not granted."
   - Tip: "Grant permission to access the file..."
   - Button: "Grant Permission"
3. Click retry → can try again

**Result:** [ ] Pass [ ] Fail [ ] Skipped (can't trigger)

---

### Test 8: User Cancellation
1. Click "Select Database Location"
2. **Cancel the file picker dialog** (press Escape or click Cancel)
3. Expected error UI:
   - Title: "File Selection Cancelled"
   - Message: "No database file was selected."
   - Recovery tip provided
   - Button: "Select File"
4. App stays in Error state (not crash)
5. Click retry → can select file again

**Result:** [ ] Pass [ ] Fail

---

**Summary:**
- Total tests: 8
- Passed: ___
- Failed: ___
- Skipped: ___

**Issues Found:**
1.
2.
3.

**Browser Compatibility:**
| Browser | Version | File System API | Fallback | Status |
|---------|---------|----------------|----------|--------|
| Chrome  | ___     | [ ] Works      | N/A      | [ ] Pass |
| Firefox | ___     | N/A            | [ ] Works| [ ] Pass |

  </how-to-verify>

  <resume-signal>
Type "approved" if all tests pass, or describe specific test failures/issues to address.

If failures found, provide:
- Test number that failed
- Expected vs actual behavior
- Console error messages (if any)
- Screenshots (optional, if helpful)
  </resume-signal>
</task>

</tasks>

<verification>
After checkpoint approval, verify:

1. **DB-03 (Handle Persistence):** File handle retrieved from IndexedDB works across browser refresh in Chrome/Edge
2. **DB-05 (Initialization Success):** Both new file creation and existing file loading complete successfully
3. **DB-06 (Fallback Storage):** LocalStorage fallback auto-activates in Firefox with data persistence
4. **ERR-03 (Format Validation):** Invalid files show user-friendly errors, empty files treated as new database

Complete workflow: First-time setup → refresh persistence → error scenarios → cross-browser fallback
</verification>

<success_criteria>
- [ ] User can select database file and it persists across browser refresh (Test 1 passes)
- [ ] Database initialization completes successfully for both new and existing files (Tests 2-3 pass)
- [ ] LocalStorage fallback works automatically in Firefox with data persistence (Test 4 passes)
- [ ] Invalid file formats show clear error messages with recovery guidance (Tests 5-8 pass)
- [ ] All 8 manual tests pass with no crashes or unclear error states
- [ ] Storage mode banner visible in Firefox, hidden in Chrome (appropriate communication)
- [ ] Error messages are user-friendly (no technical jargon, actionable recovery steps)
</success_criteria>

<output>
After completion, create `.planning/phases/03-verify-and-polish/03-01-SUMMARY.md` following the summary template.

Include in summary:
- Test results table (8 tests with pass/fail status)
- Browser compatibility matrix (Chrome, Firefox tested)
- Any issues discovered during testing
- Confirmation that all 4 requirements (DB-03, DB-05, DB-06, ERR-03) are satisfied
</output>

---
phase: 02-debug-and-fix-file-picker
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - public/file-handle-storage.js
  - src/state/file_system.rs
autonomous: true
requirements: [DB-02, DB-04, ERR-02]

must_haves:
  truths:
    - "Cached file handles are verified with queryPermission() before use"
    - "Permission prompts appear when cached handle has 'prompt' state"
    - "User can grant permissions and continue initialization with cached handle"
    - "Stale handles with 'denied' permission are cleared from IndexedDB"
  artifacts:
    - path: "public/file-handle-storage.js"
      provides: "Enhanced retrieveFileHandle with permission checking"
      contains: "queryPermission"
      min_lines: 50
    - path: "src/state/file_system.rs"
      provides: "check_cached_handle verifies permission state"
      contains: "queryPermission"
  key_links:
    - from: "src/state/file_system.rs"
      to: "file-handle-storage.js"
      via: "retrieve_file_handle() JS function call"
      pattern: "retrieve_file_handle.*await"
    - from: "public/file-handle-storage.js"
      to: "FileSystemHandle.queryPermission()"
      via: "Browser API call after IndexedDB retrieval"
      pattern: "handle\\.queryPermission"
---

<objective>
Verify permission state of cached file handles before using them, prompting user to re-grant permission if needed.

Purpose: FileSystemFileHandle persisted in IndexedDB can have expired permissions (state degrades to "prompt" after browser restart or time elapsed). Current code assumes cached handle = usable handle, causing silent failures. Need to check permission state with queryPermission() and call requestPermission() if needed.

Output: Cached handles are validated before use, permission prompts appear automatically when needed, stale denied handles are cleared.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-debug-and-fix-file-picker/02-RESEARCH.md

<interfaces>
<!-- Key interfaces from codebase and research -->

From src/state/file_system.rs:
```rust
#[wasm_bindgen(module = "/public/file-handle-storage.js")]
extern "C" {
    #[wasm_bindgen(js_name = retrieveFileHandle)]
    async fn retrieve_file_handle() -> JsValue;

    #[wasm_bindgen(js_name = clearFileHandle)]
    async fn clear_file_handle() -> JsValue;
}

impl FileSystemManager {
    pub async fn check_cached_handle(&mut self) -> Result<bool, FileSystemError>;
}
```

From FileSystemHandle Web API (MDN):
```javascript
// Permission states: "granted", "prompt", "denied"
const permission = await handle.queryPermission({ mode: 'readwrite' });

if (permission === 'granted') {
    // Can use immediately
} else if (permission === 'prompt') {
    // Need to request permission (requires user gesture in some cases)
    const newPermission = await handle.requestPermission({ mode: 'readwrite' });
} else {
    // 'denied' - user explicitly denied, handle is unusable
}
```

Permission state machine:
- "granted" → handle is immediately usable
- "prompt" → need to call requestPermission() (Chrome 122+ may auto-grant if persistent permission was set)
- "denied" → handle is unusable, should clear from IndexedDB
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: Enhance retrieveFileHandle with permission checking</name>
  <files>public/file-handle-storage.js</files>
  <action>
Modify retrieveFileHandle() function to verify permission state before returning handle. Current implementation (lines ~20-35) just returns handle if it exists in IndexedDB without checking if it's still usable.

Replace the current retrieveFileHandle implementation with:

```javascript
export async function retrieveFileHandle() {
    try {
        console.log('[FileHandleStorage] Opening IndexedDB...');
        const db = await openDB();
        const transaction = db.transaction(STORE_NAME, 'readonly');
        const store = transaction.objectStore(STORE_NAME);

        const handle = await new Promise((resolve, reject) => {
            const request = store.get(HANDLE_KEY);
            request.onsuccess = () => resolve(request.result);
            request.onerror = () => reject(request.error);
        });

        db.close();

        if (!handle) {
            console.log('[FileHandleStorage] No handle in IndexedDB');
            return null;
        }

        console.log('[FileHandleStorage] Handle found, checking permission state...');

        // CRITICAL: Check permission state before returning handle
        const options = { mode: 'readwrite' };
        const permission = await handle.queryPermission(options);
        console.log('[FileHandleStorage] Permission state:', permission);

        if (permission === 'granted') {
            console.log('[FileHandleStorage] Permission granted, handle ready to use');
            return handle;
        }

        if (permission === 'prompt') {
            // Permission expired or not yet granted
            // Chrome 122+ may auto-grant if user previously chose "Remember this choice"
            console.log('[FileHandleStorage] Permission expired, requesting...');

            try {
                const requestedPermission = await handle.requestPermission(options);
                console.log('[FileHandleStorage] Permission request result:', requestedPermission);

                if (requestedPermission === 'granted') {
                    console.log('[FileHandleStorage] Permission granted after request');
                    return handle;
                }

                console.warn('[FileHandleStorage] User denied permission request');
                await clearFileHandle();
                return null;
            } catch (error) {
                console.error('[FileHandleStorage] requestPermission failed:', error);
                // requestPermission can fail if called without user gesture in some browsers
                // Return null and let Rust code handle re-prompting from button click
                return null;
            }
        }

        // permission === 'denied'
        console.warn('[FileHandleStorage] Permission permanently denied, clearing stale handle');
        await clearFileHandle();
        return null;

    } catch (error) {
        console.error('[FileHandleStorage] Error retrieving handle:', error);
        // Handle may be invalid (file deleted, drive disconnected, etc.)
        await clearFileHandle();
        return null;
    }
}
```

This implements the full permission state machine: granted → use immediately, prompt → request permission (with fallback if no gesture), denied → clear stale handle.
  </action>
  <verify>
    <automated>grep -n "queryPermission\|requestPermission" public/file-handle-storage.js | head -5</automated>
  </verify>
  <done>retrieveFileHandle checks permission state with queryPermission, handles all three states (granted/prompt/denied), clears denied handles, logs detailed permission flow</done>
</task>

<task type="auto">
  <name>Task 2: Update check_cached_handle to handle permission request failures</name>
  <files>src/state/file_system.rs</files>
  <action>
Modify FileSystemManager::check_cached_handle() (lines 88-108) to properly handle the case where retrieve_file_handle returns null due to expired permissions requiring user gesture.

Current code assumes null/undefined = no handle. But with Task 1 changes, null can also mean "handle exists but permission request failed due to no user gesture".

Update check_cached_handle to:

```rust
pub async fn check_cached_handle(&mut self) -> Result<bool, FileSystemError> {
    if self.use_fallback {
        web_sys::console::log_1(
            &"[FileSystem] Using fallback storage (IndexedDB/LocalStorage)".into(),
        );
        // Fallback storage doesn't need handle caching
        return Ok(true);
    }

    web_sys::console::log_1(&"[FileSystem] Checking for cached file handle...".into());
    let handle = retrieve_file_handle().await;

    if !handle.is_null() && !handle.is_undefined() {
        web_sys::console::log_1(&"[FileSystem] Cached handle retrieved with valid permissions".into());
        self.handle = Some(handle);
        Ok(true)
    } else {
        // Could be: (1) no handle in IndexedDB, or (2) handle exists but permission denied/requires gesture
        // Both cases require user to select file via button click
        web_sys::console::log_1(&"[FileSystem] No cached handle or permissions not granted".into());
        web_sys::console::log_1(&"[FileSystem] User will need to select file location".into());
        Ok(false)
    }
}
```

The key change: null return from retrieve_file_handle now means "no usable handle" for any reason (doesn't exist, or exists but can't get permission). Both cases are handled identically: show SelectingFile UI with button.

Add comment explaining that retrieve_file_handle (modified in Task 1) now handles permission checking internally, so Rust code doesn't need to call queryPermission separately.
  </action>
  <verify>
    <automated>cargo check --target wasm32-unknown-unknown 2>&1 | grep -E "(error|warning.*check_cached_handle)" || echo "Build successful"</automated>
  </verify>
  <done>check_cached_handle treats null as "no usable handle", logs explain permission check happens in JS, both "no handle" and "permission denied" cases trigger SelectingFile UI</done>
</task>

</tasks>

<verification>
**Test Case 1: First-time user (no cached handle)**
1. Clear browser data (Settings → Clear browsing data → Cached images and files + Site data)
2. Reload app, click "Select Database Location"
3. File picker should appear, select/create .sqlite file
4. Console should show: permission state "granted" after selection
5. App should initialize successfully to Ready state

**Test Case 2: Returning user with valid permissions**
1. With cached handle from Test Case 1, refresh page (F5)
2. Console should show: "[FileHandleStorage] Permission state: granted"
3. Console should show: "[FileSystem] Cached handle retrieved with valid permissions"
4. App should go directly to Ready state without showing SelectingFile UI
5. No file picker dialog should appear

**Test Case 3: Expired permissions requiring re-grant**
1. Close and reopen browser (simulates permission expiration)
2. Reload app
3. Console should show: "[FileHandleStorage] Permission state: prompt"
4. Console should show: "[FileHandleStorage] Permission expired, requesting..."
5. If Chrome 122+ with persistent permission: auto-grants, goes to Ready
6. Otherwise: shows SelectingFile UI, user clicks button, permission prompt appears

**Test Case 4: User denied permission**
1. Grant permission initially, then revoke in browser settings (Site Settings → Permissions)
2. Reload app
3. Console should show: "[FileHandleStorage] Permission state: denied"
4. Console should show: "clearing stale handle"
5. IndexedDB should be empty (verify in DevTools → Application → IndexedDB)
6. SelectingFile UI should appear for user to select new file

Expected: All test cases complete successfully, appropriate permission state logged, no NotAllowedError failures.
</verification>

<success_criteria>
- [ ] Cached handles are checked with queryPermission() before use (visible in console logs)
- [ ] Handles with "granted" permission are used immediately without prompting
- [ ] Handles with "prompt" permission trigger requestPermission() or show UI button
- [ ] Handles with "denied" permission are cleared from IndexedDB
- [ ] User can successfully re-grant permissions for expired handles
- [ ] Console logs show permission state transitions (granted/prompt/denied)
</success_criteria>

<output>
After completion, create `.planning/phases/02-debug-and-fix-file-picker/02-02-SUMMARY.md`
</output>
